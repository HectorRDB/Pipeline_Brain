---
author: "Hector Roux de BÃ©zieux"
date: '`r format(Sys.time(), "%d %B , %Y")`'
output:
  html_document:
    toc: true
    toc_depth: 2
    number_sections: true
    code_download: TRUE
    
    
params:
  dataset: SMARTer_cells_MOp 
  title: "Analysis of the SMARTer_cells_MOp dataset"
---
---
title: `r params$title`
---

```{r packages, include=F}
library(knitr)
opts_chunk$set(
  fig.pos = "!h", out.extra = "", warning = F, message = F,
  fig.width = 5, fig.align = "center", echo = F
)
libs <- c("here", "tidyverse", "cowplot", "clusterExperiment", "mclust",
          "RColorBrewer", "progress")
suppressMessages(
  suppressWarnings(sapply(libs, require, character.only = TRUE))
)
rm(libs)
suppressMessages(suppressWarnings(source(here("Report", "helper.R"))))
type <- type(params$dataset)
mergers <- readRDS(here("data", type, paste0(params$dataset, "_mergers.rds")))

mergers_no_allen <- readRDS(here("data", type,
                                 paste0(params$dataset, "_no_allen_mergers.rds")))
```

# EDA

We can first visualize the data after dimension reduction with zinbWave. We then use t-SNE and color the cells with the allen labels. Since we use various values for the k parameter, we plot two representations with the most extreme values of k.

```{r, fig.width=9, fig.height=9}
plot <- list.files(here("Figures", "EDA"))
plot <- plot[str_detect(plot, params$dataset)]
plot_grid(ggdraw() + draw_image(here("Figures", "EDA", plot[1])),
          ggdraw() + draw_image(here("Figures", "EDA", plot[length(plot)])),
          ncol = 2)
```


# General comments

We have the following workflow

```{r workflow}
ggdraw() + draw_image(here("Figures", "SMART-Seq_workflow.png"))
```

In the Seurat clustering, there are two parameters to choose from: the resolution and the k.param (use in a knn step). From the seurat help file, for the resolution parameter: use a value above (below) 1.0 if you want to obtain a larger (smaller) number of communities.

We picked a value of 1.6 as we want many clusters to start with. We also pick k = 50. Those values seem intermediate in term of ARI with other pairs of paramters (see section Seurat ARI param)

We also consider two ways of computing the ARI between RSEC and other methods. Either, we force RSEC to assign all cells to a given cluster, or we only compute the ARI between RSEC and the other methods on those cells that RSEC do cluster. Note that in the second case, other pairs of methods are compared using all cells. We denote as RsecT the cluster assignement where all cells are assigned (i.e Rsec Total). 

The ARI merging method works as follow. We iterate over all pairs of clusters for every clustering method. For each pair, we try to merge the two clusters and see how it improves the ARI with the other methods. We then merge the pair that improves the ARI the most. We stop when the ARI cannot be improved anymore.

In the general case, we perform the ARI merging without the allen labels and we then use it as a comparison. A quick overview of how the algorithm performs with the allen labels is seen at the end.

# Reduction in the number of clusters

```{r Imp no allen}
plotPrePost(mergers_no_allen)
```

# Improvement in ARI

```{r ARI imp no allen cell}
plotARIReduce(mergers_no_allen)
```


```{r ARI trend, fig.width=9}
ARItrend(merger = mergers_no_allen)
```

# Comparison with Allen subclass

## After ARI merging

```{r comp cell}
allen_clusters <- read.csv(here("data", type,
                                paste0(params$dataset, "_cluster.membership.csv")),
                           col.names = c("cells", "cluster_id"))
clusters <- read.csv(here("data", type,
                          paste0(params$dataset, "_cluster.annotation.csv")),
                     header = T)
allen_clusters <- full_join(allen_clusters, clusters)
rm(clusters)

apply(mergers_no_allen$currentMat, 2, function(x) {
    inds <- x != -1
    xa <- x[inds]
    y <- allen_clusters$subclass_label[inds]
    mclust::adjustedRandIndex(xa, y)
}) %>% data.frame(method = names(.), ARI = round(., 2)) %>%
  kable(row.names = F)
```

## After a last consensus step

```{r}
clusters <- mergers_no_allen$currentMat
clusters[, "Rsec"] <- assignRsec(mergers_no_allen)

cellsConsensus <- suppressWarnings(
  makeConsensus(x = clusters, clusterLabel = "makeConsensus",
                  proportion = 2/3, minSize = 20)
  )
consensus <- cbind(cellsConsensus$clustering,
                   allen_clusters$subclass_label,
                   clusters)

colnames(consensus)[c(1, 2)] <- c("Consensus", "Allen\nsubclass")
plotClusters(object = consensus)
title("Consensus Merging with proportion and comparison with the allen subclass.")

rm(clusters, cellsConsensus, consensus)
```

## Stopping during the merging

```{r}
allen_ARI <- function(clus, allen) {
  inds <- clus == -1
  adjustedRandIndex(clus[!inds], allen[!inds])
}
allenClustersARIchange <- FTracking(merger = mergers_no_allen,
                            f = allen_ARI,
                            allen = mergers$initalMat[,"allen"])
allenClustersARIchange <- rowMeans(allenClustersARIchange)
allenSubclassARIChange <- FTracking(merger = mergers_no_allen,
                                    f = allen_ARI,
                                    allen = allen_clusters$subclass_label)
allenSubclassARIChange <- rowMeans(allenSubclassARIChange)
df <- data.frame(step = seq_along(allenClustersARIchange),
                 ARI_cluster = allenClustersARIchange,
                 ARI_subclass = allenSubclassARIChange) %>%
  gather(key = "type", value = "meanARI", -step)
ggplot(df, aes(x = step, y = meanARI, col = type)) +
  geom_line() +
  theme_classic() +
  scale_y_continuous(limits = c(0, 1)) +
  labs(title = "Mean ARI between the three methods and the allen labels\nas we process on the ARI clustering") +
  theme(title = element_text(hjust = .5))
```

```{r}
rm(allenClustersARIchange, allenSubclassARIChange,
   plot, df, allen_ARI)

midMat <- intermediateMat(merger = mergers_no_allen,
                          p = .9)
midMat[, "Rsec"] <- assignRsec(mergers_no_allen, p = .9)

cellsConsensus <- suppressWarnings(
  makeConsensus(x = midMat, clusterLabel = "makeConsensus",
                proportion = 2/3, minSize = 20)
  )
consensus <- cbind(cellsConsensus$clustering,
                   allen_clusters$subclass_label,
                   midMat)

colnames(consensus)[c(1, 2)] <- c("Consensus", "Allen\nsubclass")
plotClusters(object = consensus)
title("Consensus Merging when stopping early")

rm(cellsConsensus, consensus, midMat)
```

```{r, eval = FALSE}
ImpARI <- ARItrendAllen(merger = mergers_no_allen,
                        allen1 = allen_clusters$cluster_label,
                        allen2 = allen_clusters$subclass_label,
                        verbose = TRUE)

ggplot(data.frame(step = 0:nrow(mergers_no_allen$merges),
                  subclassAllen = ImpARI[, 2],
                  clusterAllen = ImpARI[, 1]) %>%
         gather(key = "type", value = "ImpARI", -step),
       aes(x = step, y = ImpARI)) +
  geom_line(aes(col = type)) +
  scale_y_continuous(limits = c(0, 1))
```

We can see that the ARI may not be the best metric for that comparison.

# ARI clustering with the Allen dataset 
## Reduction in the number of clusters
```{r allen}
plotPrePost(mergers)
```

## Improvement in ARI

```{r ARI_imp_allen}
plotARIReduce(mergers)
```

# Seurat ARI Param

```{r}
ggdraw() + draw_image(here("Figures", type,
                           paste0(params$dataset, "_seurat_ARI.pdf"))
                      )
```